
import os
import sys
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv


'''
1) Grab
'''# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py
def info_test():
    f = open("q1.txt", "r")
    phi_arr = f.readlines()
    print('------------------------')
    print(phi_arr)
    S = phi_arr[0].strip('\n')
    n = phi_arr[1].strip('\n')
    V = phi_arr[2].strip('\n')
    F_VECT = phi_arr[3].strip('\n')
    PRED_LIST = phi_arr[4].strip('\n')
    HAVING = phi_arr[5].strip('\n')
    print(S)
    print(n)
    print(V)
    print(F_VECT)
    print(PRED_LIST)
    print(HAVING)
    print('------------------------')

    mf_struct = {}

    GROUP_BY_ATTRS = V.split(',')
    GROUP_BY_STR = ""
    for attr in GROUP_BY_ATTRS:
        if attr == GROUP_BY_ATTRS[0]:
            GROUP_BY_STR += attr.strip()
        else:
            GROUP_BY_STR += "_" + attr.strip()
    

    GBKEYS_LIST = []

    {
        "cust_prod": {
            "joe_fruit": {
                "count_2_quant": 0,
                "max_3_quant": -1
            }
        }

    }

    F_VECT_COMPONENT_ARR = F_VECT.split(',')




    # Flags to determine if this exists among any of the aggregates after looping through each individually
    # count_flag = False
    # sum_flag = False
    # max_flag = False
    # min_flag = False
    # avg_flag = False

    # for agg in F_VECT_COMPONENT_ARR:
    #     current_aggregate = agg.split('_')
    
    print('------------------------')
   
    return mf_struct

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    f = open("q1.txt", "r")
    phi_arr = f.readlines()
    print('------------------------')
    print(phi_arr)
    S = phi_arr[0].strip('\n')
    n = phi_arr[1].strip('\n')
    V = phi_arr[2].strip('\n')
    F_VECT = phi_arr[3].strip('\n')
    PRED_LIST = phi_arr[4].strip('\n')
    HAVING = phi_arr[5].strip('\n')
    print(S)
    print(n)
    print(V)
    print(F_VECT)
    print(PRED_LIST)
    print(HAVING)
    print('------------------------')

    mf_struct = {}
    pred_dict = {}
    typecast_dict = {
        'cust' : 'string',
        'prod' : 'string',
        'day'  : 'int',
        'month': 'int',
        'year' : 'int',
        'state': 'string',
        'quant': 'int',
        'date' : 'date'
    }

    PRED_ARR = PRED_LIST.split(';')

    # {
    #     1: ['1.quant_!=_100', '1.state_=_NY', '1.quant_>_10', '1.quant>_2.quant']
    #     2: {}
    #     3: {}
    # }

# [2,1,3]
    # Initialize dictionary for predicates
    PRED_KEYS = []
    for pred in PRED_ARR:
        grp_var = pred[:pred.find('.')]
        comparison = pred[(pred.find('.') + 1):]
        print("AAAAAAAAAA")
        print(grp_var)
        print(comparison)
        if grp_var in PRED_KEYS:
            pass
        else:
            PRED_KEYS.append(grp_var)
            pred_dict[grp_var] = []

    possible_comparisons = ['!', '<', '>', '=']
    for pred in PRED_ARR:
        grp_var = pred[:pred.find('.')]
        comparison = pred[(pred.find('.') + 1):]
        pred_attr = ''
        pred_symbol = ''
        pred_value = ''
        temp_index = 0
        for letter in comparison:
            if (letter not in possible_comparisons):
                temp_index += 1
                pred_attr += letter
            else:
                break

        for letter in comparison[temp_index:]:
            if letter in possible_comparisons:
                temp_index += 1
                pred_symbol += letter
            else:
                break

        pred_value = comparison[temp_index:]
        
        pred_str = f"{pred_attr}_{pred_symbol}_{pred_value}"
        pred_dict[grp_var].append(pred_str)
        
        
        
    GROUP_BY_ATTRS = V.split(',')
    GROUP_BY_STR = ""
    for attr in GROUP_BY_ATTRS:
        if attr == GROUP_BY_ATTRS[0]:
            GROUP_BY_STR += attr.strip()
        else:
            GROUP_BY_STR += "_" + attr.strip()
    

    GBKEYS_LIST = []
    for row in cur:
        row_attr_str = ""
        if row['quant'] > 999:
            # For eaceh row, create a string consisting of the values of each group by attribute, separated by _'s.
            for attr in GROUP_BY_ATTRS:
                attr_str = attr.strip()
                if attr == GROUP_BY_ATTRS[0]:
                    row_attr_str += row[attr_str]
                else:
                    row_attr_str += "_" + row[attr_str]
            if row_attr_str in GBKEYS_LIST:
                pass
            else:
                GBKEYS_LIST.append(row_attr_str)
                
    #Creates dictionary of unique grouping attributes and empty dictionary which will eventually contain the agg. vals
    for key in GBKEYS_LIST:
        mf_struct[key] = {}

    # Initialization of base values for aggregate functions for every unique combination of attributes
    F_VECT_COMPONENT_ARR = F_VECT.split(',')
    for key in mf_struct.keys():
        for agg in F_VECT_COMPONENT_ARR:
            # agg = 'count_2_quant'
            [agg_func, agg_table, agg_attr] = agg.split('_')
            if agg_func == 'count':
                # e.g. key = 'joe_fruit', agg = 'count_2_quant'
                mf_struct[key][agg] = 0
            elif agg_func == 'sum':
                # e.g. key = 'joe_fruit', agg = 'count_2_quant'
                mf_struct[key][agg] = 0
            elif agg_func == 'min':
                # e.g. key = 'joe_fruit', agg = 'count_2_quant'
                # Highest 
                mf_struct[key][agg] = None
            elif agg_func == 'max':
                # e.g. key = 'joe_fruit', agg = 'count_2_quant'
                mf_struct[key][agg] = None
            elif agg_func == 'avg':
                # e.g. key = 'joe_fruit', agg = 'count_2_quant'
                # avg saved as {sum, count}
                # when completed with full loop to add aggregates: set mf_struct[key][agg] = mf_struct[key][agg]['average'] for all aggregates which agg_func == 'avg'
                mf_struct[key][agg] = {'sum': 0, 'count': 0}
            else:
                raise Exception(f"Unknown aggregate function when initializing mf_struct aggregate values: {agg_func}")
    
    # return mf_struct
    # mf_struct has been initialized with the initial values correspoding to the aggregate functions

    cur.scroll(0, 'absolute')
    for row in cur:
        row_attr_str = ""
        if row['quant'] > 999:
            print('-------------------------------------')
            print(row)
            # For eaceh row, create a string consisting of the values of each group by attribute, separated by _'s.
            for attr in GROUP_BY_ATTRS:
                attr_str = attr.strip()
                if attr == GROUP_BY_ATTRS[0]:
                    row_attr_str += row[attr_str]
                else:
                    row_attr_str += "_" + row[attr_str]
            # print(GBKEYS_LIST)
            # print(row_attr_str)
            if row_attr_str.strip() in GBKEYS_LIST:
                row_aggregates = mf_struct[row_attr_str].keys()
                # row_aggregate e.g. = 'count_1_quant'
                fits_table_flag = True
                for row_aggregate in row_aggregates:
                    fits_table_flag = True
                    [row_agg_func, row_agg_table, row_agg_attr] = row_aggregate.split('_')
                    # print("______")
                    # print(row_agg_func)
                    # print('000000000')

                    #Returns a list of all the conditions
                    # example is quant_>_100 (attr_symbol_value)
                    conditions_array = pred_dict[row_agg_table]
                    for row_condition in conditions_array:
                        [cond_attr, symbol, value] = row_condition.split('_')
                        value = value.replace("'", "")
                        # print('+++++++++++++++++++++++++++++=')
                        # print(cond_attr)
                        # print(symbol)
                        # print(value)
                        # print('________________________________')
                        if symbol == '>':
                            if not row[cond_attr] > value:
                                fits_table_flag = False
                        elif symbol == '>=':
                            if not row[cond_attr] >= value:
                                fits_table_flag = False
                        elif symbol == '<':
                            if not row[cond_attr] < value:
                                fits_table_flag = False
                        elif symbol == '<=':
                            if not row[cond_attr] <= value:
                                fits_table_flag = False
                        elif symbol == '=':
                            # print('im in the = method')
                            # print(row[cond_attr])
                            # print(value)
                            # print(row[cond_attr] == value)
                            # print('0000000000000000')
                            if not row[cond_attr] == value:
                                fits_table_flag = False
                        elif symbol == '!=':
                            if not row[cond_attr] != value:
                                fits_table_flag = False
                        
                    # print('fits table flag after cond loop:', fits_table_flag)
                    # Conditions for the table have been checked. If the row fits the conditions of the table:
                    if fits_table_flag:
                        # print('fits table flag is true')
                        # print('row agg func:', row_agg_func)
                        if row_agg_func == 'count':
                            mf_struct[row_attr_str][row_aggregate] =  mf_struct[row_attr_str][row_aggregate] + 1
                        elif row_agg_func == 'sum':
                            mf_struct[row_attr_str][row_aggregate] =  mf_struct[row_attr_str][row_aggregate] + int(row[row_agg_attr])
                        elif row_agg_func == 'min':
                            if typecast_dict[cond_attr] == 'string':
                                if mf_struct[row_attr_str][row_aggregate] == None:
                                    mf_struct[row_attr_str][row_aggregate] = str(row[row_agg_attr])
                                elif str(row[row_agg_attr]) < mf_struct[row_attr_str][row_aggregate]:
                                    mf_struct[row_attr_str][row_aggregate] = str(row[row_agg_attr])
                            elif typecast_dict[cond_attr] == 'int':
                                if mf_struct[row_attr_str][row_aggregate] == None:
                                    mf_struct[row_attr_str][row_aggregate] = int(row[row_agg_attr])
                                elif int(row[row_agg_attr]) < mf_struct[row_attr_str][row_aggregate]:
                                    mf_struct[row_attr_str][row_aggregate] = int(row[row_agg_attr])
                            elif typecast_dict[cond_attr] == 'date':
                                #TODO
                                pass
                        elif row_agg_func == 'max':
                            # print('Im in max')
                            if typecast_dict[cond_attr] == 'string':
                                # print('type = string')
                                if mf_struct[row_attr_str][row_aggregate] == None:
                                    # print('mf struct row attr = None')
                                    mf_struct[row_attr_str][row_aggregate] = str(row[row_agg_attr])
                                elif str(row[row_agg_attr]) > mf_struct[row_attr_str][row_aggregate]:
                                    # print('mf struct row attr exists')
                                    mf_struct[row_attr_str][row_aggregate] = str(row[row_agg_attr])
                            elif typecast_dict[cond_attr] == 'int':
                                # print('type = int')
                                if mf_struct[row_attr_str][row_aggregate] == None:
                                    # print('mf struct row attr = None')
                                    mf_struct[row_attr_str][row_aggregate] = int(row[row_agg_attr])
                                elif int(row[row_agg_attr]) > mf_struct[row_attr_str][row_aggregate]:
                                    # print('mf struct row attr exists')
                                    mf_struct[row_attr_str][row_aggregate] = int(row[row_agg_attr])
                            elif typecast_dict[cond_attr] == 'date':
                                # print('type = date')
                                #TODO
                                pass
                        elif row_agg_func == 'avg':
                            mf_struct[row_attr_str][row_aggregate]['count'] =  mf_struct[row_attr_str][row_aggregate]['count'] + 1
                            mf_struct[row_attr_str][row_aggregate]['sum'] = mf_struct[row_attr_str][row_aggregate]['sum'] + int(row[row_agg_attr])            
            else:
                raise Exception("Key not in list: " + row_attr_str)
    
    return mf_struct

    # {
    #     "cust_prod": {
    #         "joe_fruit": {
    #             "count_2_quant": 0,
    #             "max_3_quant":, -1
    #         }
    #     }

    # }

    # for row in cur:
    #     if row['quant'] > 10:
    #         _global.append(row)
    
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    # print(info_test())
    
if "__main__" == __name__:
    main()
    